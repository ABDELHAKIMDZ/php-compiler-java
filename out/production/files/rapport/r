```markdown
# Rapport de Projet : Analyseur Lexical et Syntaxique pour PHP Simplifi√©

## üìã Introduction
Ce projet consiste en la mise en ≈ìuvre d'un analyseur lexical et syntaxique pour un sous-ensemble du langage PHP ,
 utilisant la technique de **descente r√©cursive**. L'objectif est de comprendre les principes fondamentaux de
 la construction des compilateurs.

## üèóÔ∏è Architecture du Projet

### Fichiers Impl√©ment√©s

 1. **TokenType.java**
**R√¥le** : D√©finition des types de tokens reconnus par l'analyseur lexical.
- **Mots-cl√©s** : `VAR`, `IF`, `ELSE`, `WHILE`, `FOREACH`, `AS`
- **Identifiants** : `IDENTIFIER` (avec ou sans `$`)
- **Litt√©raux** : `NUMBER`, `STRING`
- **Op√©rateurs** :
  - Arithm√©tiques : `PLUS`, `MINUS`, `MUL`, `DIV`
  - Comparaison : `EQ`, `NEQ`, `LT`, `GT`, `LE`, `GE`
  - Logiques : `AND`, `OR`
  - Incr√©mentation : `INC`, `DEC`
  - Assignation : `ASSIGN`
- **D√©limiteurs** :
  - Parenth√®ses : `LPAREN`, `RPAREN`
  - Accolades : `LBRACE`, `RBRACE`
  - Crochets : `LBRACKET`, `RBRACKET`
  - Ponctuation : `COMMA`, `SEMICOLON`, `DOT`, `QUESTION`, `COLON`


  #### 2. **Token.java**
  **R√¥le** : Repr√©sentation d'un token avec son type, valeur et ligne.
  ```java
  public class Token {
      public TokenType type;
      public String value;
      public int line;
  }
  ```


#### 3. **Lexer.java**
**R√¥le** : Analyseur lexical convertissant le code source en flux de tokens.

**M√©thodes principales** :
- `tokenize()` : Conversion caract√®res ‚Üí tokens
- `readIdentifierOrKeyword()` : Lecture identifiants/mots-cl√©s
- `readString()` : Lecture cha√Ænes de caract√®res
- `readNumber()` : Lecture nombres

#### 4. **Parser.java**
**R√¥le** : Analyseur syntaxique v√©rifiant la structure grammaticale.

#### 5. **SyntaxException.java**
**R√¥le** : Gestion des erreurs syntaxiques avec num√©ros de ligne.


#### 6. **Main.java**
**R√¥le** : Point d'entr√©e du programme, orchestration de l'analyse.

## üîç M√©thodologie : Descente R√©cursive

### Principe de la Descente R√©cursive
La **descente r√©cursive** est une m√©thode d'analyse syntaxique descendante o√π chaque production de la grammaire est impl√©ment√©e comme une fonction r√©cursive.


### Application dans le Projet

#### **Fonctions Principales du Parser**

1. **`parseProgram()`** - Point d'entr√©e
```java
public void parseProgram() {
    while (peek().type != TokenType.EOF) {
        parseStatement();
    }
}
```

2. **`parseStatement()`** - Distribution aux diff√©rentes structures
```java
private void parseStatement() {
    switch (peek().type) {
        case VAR: parseVarDecl(); break;
        case IF: parseIf(); break;
        case WHILE: parseWhile(); break;
        // ...
    }
}
```

3. **Fonctions Sp√©cialis√©es** :
   - `parseVarDecl()` : D√©clarations de variables
   - `parseIf()`, `parseWhile()`, `parseForeach()` : Structures de contr√¥le
   - `parseExpression()` : Expressions arithm√©tiques et logiques

### Avantages de la Descente R√©cursive

- ‚úÖ **Simplicit√©** : Code proche de la grammaire
- ‚úÖ **Maintenabilit√©** : Facile √† comprendre et modifier
- ‚úÖ **D√©tection d'erreurs pr√©cise** : Localisation exacte des probl√®mes
- ‚úÖ **Adaptabilit√©** : Extension ais√©e de la grammaire


## üìä Analyse Lexicale

### Processus d'Analyse Lexicale

1. **Segmentation** : D√©coupage du code en tokens
2. **Classification** : Identification du type de chaque token
3. **Validation** : V√©rification de la conformit√© lexicale

### Tokens Support√©s

- **Mots-cl√©s** : `var`, `if`, `else`, `while`, `foreach`, `as`
- **Identifiants** : Variables avec `$` ou sans
- **Litt√©raux** : Nombres, cha√Ænes de caract√®res
- **Op√©rateurs** : Arithm√©tiques (`+`, `-`, `*`, `/`), de comparaison (`==`, `!=`, `<`, `>`), logiques (`&&`, `||`)
- **D√©limiteurs** : Parenth√®ses, accolades, crochets, points-virgules


## üìê Analyse Syntaxique

### Grammaire Impl√©ment√©e

```
Prog        ‚Üí StmtList
StmtList    ‚Üí Stmt StmtList | Œµ

Stmt        ‚Üí VarDecl ';'
            | Assignment ';'
            | IfStmt
            | WhileStmt
            | ForEachStmt
            | IncDecStmt ';'
            | Comparison ';'

VarDecl     ‚Üí 'var' Identifier [ '=' Expr ]
Assignment  ‚Üí Identifier '=' Expr
IncDecStmt  ‚Üí Identifier ( '++' | '--' )
Comparison  ‚Üí Expr ComparisonOp Expr

IfStmt      ‚Üí 'if' '(' Expr ')' '{' StmtList '}' [ 'else' '{' StmtList '}' ]
WhileStmt   ‚Üí 'while' '(' Expr ')' '{' StmtList '}'

ForEachStmt ‚Üí 'foreach' '(' Identifier 'as' Identifier ')' '{' StmtList '}'

Expr        ‚Üí Expr ( '+' | '-' | '*' | '/' | '&&' | '||' ) Expr
            | '(' Expr ')'
            | Identifier
            | Number
            | String

ComparisonOp ‚Üí '==' | '!=' | '<' | '>' | '<=' | '>='

Identifier  ‚Üí [a-zA-Z_][a-zA-Z0-9_]*
Number      ‚Üí [0-9]+
String      ‚Üí '"' .* '"'
```



### V√©rifications Syntaxiques

- ‚úÖ Structure des blocs (`{}`, `()`, `[]`)
- ‚úÖ Point-virgules terminaux
- ‚úÖ Expressions bien form√©es
- ‚úÖ Correspondance des structures de contr√¥le

## üß™ Tests et Validation

### Cas de Test Valid√©s

1. **D√©clarations simples** : `var x = 10;`
2. **Structures de contr√¥le** : `if`, `while`, `foreach`
3. **Expressions complexes** : `$result = ($a + $b) * $c;`
4. **Tableaux** : `$numbers = [1, 2, 3];`
5. **Programmes complets** avec structures imbriqu√©es

### D√©tection d'Erreurs

L'analyseur d√©tecte :
- ‚ùå Cha√Ænes non ferm√©es
- ‚ùå Points-virgules manquants
- ‚ùå Parenth√®ses non correspondantes
- ‚ùå Expressions incompl√®tes
- ‚ùå Structures mal form√©es

Strat√©gie de R√©cup√©ration
Approche "Fail-Fast" :

D√©tection imm√©diate √† la premi√®re erreur

Arr√™t du parsing avec message descriptif

Localisation pr√©cise (num√©ro de ligne)


## üéØ R√©sultats

### Succ√®s du Projet

- ‚úÖ **Analyseur lexical fonctionnel** : Tokenisation correcte
- ‚úÖ **Analyseur syntaxique robuste** : V√©rification structurelle
- ‚úÖ **Gestion d'erreurs efficace** : Messages informatifs
- ‚úÖ **Couverture grammaticale** : Support du PHP simplifi√©

##Conclusion

Ce projet a d√©montr√© la mise en ≈ìuvre r√©ussie d'un analyseur lexical et syntaxique utilisant la m√©thode de descente r√©cursive.
 L'analyseur supporte un sous-ensemble significatif de PHP incluant les structures de contr√¥le avanc√©es comme foreach.