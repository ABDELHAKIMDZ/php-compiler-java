```markdown
# Rapport de Projet : Analyseur Lexical et Syntaxique pour PHP Simplifi√©

## üìã Introduction
Ce projet consiste en la mise en ≈ìuvre d'un analyseur lexical et syntaxique pour un sous-ensemble du langage PHP ,
 utilisant la technique de **descente r√©cursive**. L'objectif est de comprendre les principes fondamentaux de
 la construction des compilateurs.

## üèóÔ∏è Architecture du Projet

### Fichiers Impl√©ment√©s
 1. **TokenType.java**
**R√¥le** : D√©finition des types de tokens reconnus par l'analyseur lexical.
```java
public enum TokenType {
    // Mots-cl√©s, identifiants, litt√©raux, op√©rateurs, d√©limiteurs
}
```

#### 2. **Token.java**
**R√¥le** : Repr√©sentation d'un token avec son type, valeur et ligne.
```java
public class Token {
    public TokenType type;
    public String value;
    public int line;
}
```

#### 3. **Lexer.java**
**R√¥le** : Analyseur lexical convertissant le code source en flux de tokens.

**M√©thodes principales** :
- `tokenize()` : Conversion caract√®res ‚Üí tokens
- `readIdentifierOrKeyword()` : Lecture identifiants/mots-cl√©s
- `readString()` : Lecture cha√Ænes de caract√®res
- `readNumber()` : Lecture nombres

#### 4. **Parser.java**
**R√¥le** : Analyseur syntaxique v√©rifiant la structure grammaticale.

#### 5. **SyntaxException.java**
**R√¥le** : Gestion des erreurs syntaxiques avec num√©ros de ligne.

#### 6. **Main.java**
**R√¥le** : Point d'entr√©e du programme, orchestration de l'analyse.

## üîç M√©thodologie : Descente R√©cursive

### Principe de la Descente R√©cursive
La **descente r√©cursive** est une m√©thode d'analyse syntaxique descendante o√π chaque production de la grammaire est impl√©ment√©e comme une fonction r√©cursive.

### Application dans le Projet

#### **Fonctions Principales du Parser**

1. **`parseProgram()`** - Point d'entr√©e
```java
public void parseProgram() {
    while (peek().type != TokenType.EOF) {
        parseStatement();
    }
}
```

2. **`parseStatement()`** - Distribution aux diff√©rentes structures
```java
private void parseStatement() {
    switch (peek().type) {
        case VAR: parseVarDecl(); break;
        case IF: parseIf(); break;
        case WHILE: parseWhile(); break;
        // ...
    }
}
```

3. **Fonctions Sp√©cialis√©es** :
   - `parseVarDecl()` : D√©clarations de variables
   - `parseIf()`, `parseWhile()`, `parseForeach()` : Structures de contr√¥le
   - `parseExpression()` : Expressions arithm√©tiques et logiques

### Avantages de la Descente R√©cursive

- ‚úÖ **Simplicit√©** : Code proche de la grammaire
- ‚úÖ **Maintenabilit√©** : Facile √† comprendre et modifier
- ‚úÖ **D√©tection d'erreurs pr√©cise** : Localisation exacte des probl√®mes
- ‚úÖ **Adaptabilit√©** : Extension ais√©e de la grammaire

## üìä Analyse Lexicale

### Processus d'Analyse Lexicale

1. **Segmentation** : D√©coupage du code en tokens
2. **Classification** : Identification du type de chaque token
3. **Validation** : V√©rification de la conformit√© lexicale

### Tokens Support√©s

- **Mots-cl√©s** : `var`, `if`, `else`, `while`, `foreach`, `as`
- **Identifiants** : Variables avec `$` ou sans
- **Litt√©raux** : Nombres, cha√Ænes de caract√®res
- **Op√©rateurs** : Arithm√©tiques (`+`, `-`, `*`, `/`), de comparaison (`==`, `!=`, `<`, `>`), logiques (`&&`, `||`)
- **D√©limiteurs** : Parenth√®ses, accolades, crochets, points-virgules

## üìê Analyse Syntaxique

### Grammaire Impl√©ment√©e

```
Program ‚Üí Statement*
Statement ‚Üí VarDecl | Assignment | If | While | Foreach
VarDecl ‚Üí "var" IDENTIFIER ("=" Expression)?
Assignment ‚Üí IDENTIFIER ("=" Expression | "++" | "--")
If ‚Üí "if" "(" Expression ")" "{" Statement* "}" ("else" "{" Statement* "}")?
While ‚Üí "while" "(" Expression ")" "{" Statement* "}"
Foreach ‚Üí "foreach" "(" IDENTIFIER "as" IDENTIFIER ")" "{" Statement* "}"
Expression ‚Üí Primary (Operator Primary)*
Primary ‚Üí NUMBER | STRING | IDENTIFIER | "(" Expression ")" | ArrayLiteral
```

### V√©rifications Syntaxiques

- ‚úÖ Structure des blocs (`{}`, `()`, `[]`)
- ‚úÖ Point-virgules terminaux
- ‚úÖ Expressions bien form√©es
- ‚úÖ Correspondance des structures de contr√¥le

## üß™ Tests et Validation

### Cas de Test Valid√©s

1. **D√©clarations simples** : `var x = 10;`
2. **Structures de contr√¥le** : `if`, `while`, `foreach`
3. **Expressions complexes** : `$result = ($a + $b) * $c;`
4. **Tableaux** : `$numbers = [1, 2, 3];`
5. **Programmes complets** avec structures imbriqu√©es

### D√©tection d'Erreurs

L'analyseur d√©tecte :
- ‚ùå Cha√Ænes non ferm√©es
- ‚ùå Points-virgules manquants
- ‚ùå Parenth√®ses non correspondantes
- ‚ùå Expressions incompl√®tes
- ‚ùå Structures mal form√©es

## üéØ R√©sultats et Conclusion

### Succ√®s du Projet

- ‚úÖ **Analyseur lexical fonctionnel** : Tokenisation correcte
- ‚úÖ **Analyseur syntaxique robuste** : V√©rification structurelle
- ‚úÖ **Gestion d'erreurs efficace** : Messages informatifs
- ‚úÖ **Couverture grammaticale** : Support du PHP simplifi√©

### Comp√©tences D√©velopp√©es

- Compr√©hension des **phases de compilation**
- Ma√Ætrise des **techniques d'analyse syntaxique**
- Gestion des **erreurs et exceptions**
- Conception **orient√©e objet** pour les compilateurs

### Perspectives d'Am√©lioration

- Extension de la grammaire (fonctions, classes)
- G√©n√©ration de code interm√©diaire
- Optimisations et analyses s√©mantiques

## üìù Conclusion

Ce projet a permis de mettre en pratique les concepts fondamentaux de la construction des compilateurs gr√¢ce √† l'impl√©mentation d'un analyseur lexical et syntaxique utilisant la m√©thode de descente r√©cursive. L'analyseur d√©montre une capacit√© robuste √† traiter un sous-ensemble significatif du langage PHP tout en fournissant des diagnostics d'erreur pr√©cis et informatifs.

**Technologie** : Java
**M√©thode** : Descente r√©cursive
**Couverture** : PHP simplifi√© avec foreach
**Statut** : ‚úÖ Fonctionnel et valid√©
```